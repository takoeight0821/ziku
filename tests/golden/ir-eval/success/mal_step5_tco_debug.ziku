-- MAL Step 5: TCO - Debug Test
-- Test what the integration test returns

-- ============================================
-- String helpers
-- ============================================
let rec strEqFrom = \s1 s2 i =>
  if i >= strLen s1 then true
  else if runeToInt(strAt s1 i) == runeToInt(strAt s2 i) then strEqFrom s1 s2 (i + 1)
  else false
in
let strEq = \s1 s2 =>
  if strLen s1 == strLen s2 then strEqFrom s1 s2 0 else false
in

-- ============================================
-- Environment
-- ============================================
let emptyEnv = Cons(MNil, MNil) in
let rec lookupBindings = \bindings sym =>
  match bindings {
  | MNil => MNil
  | Cons(Cons(MStr(name), val), rest) =>
    if strEq name sym then Cons(MTrue, val)
    else lookupBindings rest sym
  | _ => MNil
  }
in
let rec envGet = \env sym =>
  match env {
  | Cons(bindings, outer) =>
    match lookupBindings bindings sym {
    | Cons(MTrue, val) => val
    | _ => match outer { | Cons(_, _) => envGet outer sym | _ => MErr("'" ++ sym ++ "' not found") }
    }
  | _ => MErr("invalid env")
  }
in
let envSet = \env sym val =>
  match env {
  | Cons(bindings, outer) => Cons(Cons(Cons(MStr(sym), val), bindings), outer)
  | _ => Cons(Cons(Cons(MStr(sym), val), MNil), MNil)
  }
in
let rec bindParams = \params args env =>
  match params {
  | MNil => env
  | Cons(MSym(name), restParams) =>
    match args {
    | Cons(val, restArgs) => bindParams restParams restArgs (envSet env name val)
    | _ => env
    }
  | _ => env
  }
in

-- ============================================
-- Evaluator Helpers
-- ============================================
let isTruthy = \val =>
  match val {
  | MNil => false
  | MFalse => false
  | _ => true
  }
in

let rec evalList = \ev env args =>
  match args {
  | MNil => MNil
  | Cons(h, t) =>
    let hVal = label k { ev ev env h ~k } in
    Cons(hVal, evalList ev env t)
  | _ => MNil
  }
in

let applyNative = \op args =>
  if strEq op "+" then
    match args { | Cons(MNum(a), Cons(MNum(b), MNil)) => MNum(a + b) | _ => MErr("+ err") }
  else if strEq op "-" then
    match args { | Cons(MNum(a), Cons(MNum(b), MNil)) => MNum(a - b) | _ => MErr("- err") }
  else if strEq op "mod" then
    match args {
      | Cons(MNum(a), Cons(MNum(b), MNil)) => MNum(a - (a / b) * b)
      | _ => MErr("mod err")
    }
  else if strEq op "=" then
    match args {
    | Cons(MNum(a), Cons(MNum(b), MNil)) => if a == b then MTrue else MFalse
    | _ => MErr("= err")
    }
  else if strEq op "list" then args
  else if strEq op "empty?" then
    match args {
    | Cons(MNil, MNil) => MTrue
    | Cons(Cons(_, _), MNil) => MFalse
    | _ => MTrue
    }
  else if strEq op "first" then
    match args { | Cons(Cons(h, _), MNil) => h | _ => MNil }
  else if strEq op "rest" then
    match args { | Cons(Cons(_, t), MNil) => t | _ => MNil }
  else MErr("unknown native: " ++ op)
in

-- ============================================
-- Main EVAL with Explicit CPS
-- ============================================
let rec eval = \ev env ast ~k =>
  match ast {
  | MSym(s) => goto(envGet env s, k)
  | Cons(head, args) =>
    match head {
    | MSym(s) =>
      if strEq s "if" then
        match args {
        | Cons(cond, Cons(thenBranch, rest)) =>
          let condVal = label ck { ev ev env cond ~ck } in
          if isTruthy condVal then ev ev env thenBranch ~k
          else
            match rest {
            | Cons(elseBranch, _) => ev ev env elseBranch ~k
            | _ => goto(MNil, k)
            }
        | _ => goto(MErr("if needs at least cond and then"), k)
        }
      else if strEq s "do" then
        match args {
        | MNil => goto(MNil, k)
        | Cons(h, MNil) => ev ev env h ~k
        | Cons(h, t) =>
          let ignored = label dk { ev ev env h ~dk } in
          ev ev env (Cons(MSym("do"), t)) ~k
        | _ => goto(MErr("invalid do"), k)
        }
      else if strEq s "let*" then
        match args {
        | Cons(MNil, Cons(body, MNil)) => ev ev env body ~k
        | Cons(Cons(MSym(name), Cons(value, restBindings)), Cons(body, MNil)) =>
          let val = label vk { ev ev env value ~vk } in
          let newEnv = envSet env name val in
          ev ev newEnv (Cons(MSym("let*"), Cons(restBindings, Cons(body, MNil)))) ~k
        | _ => goto(MErr("invalid let*"), k)
        }
      else if strEq s "fn*" then
        match args {
        | Cons(params, Cons(body, MNil)) => goto(MClosure(params, body, env), k)
        | _ => goto(MErr("fn* needs params and body"), k)
        }
      else
        let opVal = label ok { ev ev env head ~ok } in
        match opVal {
        | MNative(name) => goto(applyNative name (evalList ev env args), k)
        | MClosure(params, body, cEnv) =>
          let evaledArgs = evalList ev env args in
          let newEnv = bindParams params evaledArgs cEnv in
          ev ev newEnv body ~k
        | _ => goto(MErr("cannot apply"), k)
        }
    | _ =>
      let opVal = label ok { ev ev env head ~ok } in
      match opVal {
      | MNative(name) => goto(applyNative name (evalList ev env args), k)
      | MClosure(params, body, cEnv) =>
        let evaledArgs = evalList ev env args in
        let newEnv = bindParams params evaledArgs cEnv in
        ev ev newEnv body ~k
      | _ => goto(MErr("cannot apply"), k)
      }
    }
  | MNum(n) => goto(MNum(n), k)
  | MNil => goto(MNil, k)
  | MTrue => goto(MTrue, k)
  | MFalse => goto(MFalse, k)
  | _ => goto(ast, k)
  }
in

-- ============================================
-- Test Setup
-- ============================================
let initialEnv =
  let e1 = envSet emptyEnv "+" (MNative("+")) in
  let e2 = envSet e1 "-" (MNative("-")) in
  let e3 = envSet e2 "mod" (MNative("mod")) in
  let e4 = envSet e3 "=" (MNative("=")) in
  let e5 = envSet e4 "list" (MNative("list")) in
  let e6 = envSet e5 "empty?" (MNative("empty?")) in
  let e7 = envSet e6 "first" (MNative("first")) in
  let e8 = envSet e7 "rest" (MNative("rest")) in
  e8
in

-- Test 1: just (+ 1 2) -> 3
let test1 = Cons(MSym("+"), Cons(MNum(1), Cons(MNum(2), MNil))) in
let result1 = label exit1 { eval eval initialEnv test1 ~exit1 } in
let r1str = match result1 {
| MNum(n) => "MNum:" ++ intToStr n
| MErr(m) => "MErr:" ++ m
| _ => "Other"
} in

-- Test 2: (let* [] 42) -> 42
let test2 = Cons(MSym("let*"), Cons(MNil, Cons(MNum(42), MNil))) in
let result2 = label exit2 { eval eval initialEnv test2 ~exit2 } in
let r2str = match result2 {
| MNum(n) => "MNum:" ++ intToStr n
| MErr(m) => "MErr:" ++ m
| _ => "Other"
} in

-- Test 3: (let* [x 1] x) -> 1
let test3 = Cons(MSym("let*"), Cons(Cons(MSym("x"), Cons(MNum(1), MNil)), Cons(MSym("x"), MNil))) in
let result3 = label exit3 { eval eval initialEnv test3 ~exit3 } in
let r3str = match result3 {
| MNum(n) => "MNum:" ++ intToStr n
| MErr(m) => "MErr:" ++ m
| MSym(s) => "MSym:" ++ s
| _ => "Other"
} in

-- Test 3b: What does env lookup for unbound 'x' return?
let result3b = envGet initialEnv "x" in
let r3bstr = match result3b {
| MErr(m) => "MErr:" ++ m
| _ => "Other"
} in

-- Test 4: (fn* [x] x) -> closure
let test4 = Cons(MSym("fn*"), Cons(Cons(MSym("x"), MNil), Cons(MSym("x"), MNil))) in
let result4 = label exit4 { eval eval initialEnv test4 ~exit4 } in
let r4str = match result4 {
| MClosure(_, _, _) => "MClosure"
| MErr(m) => "MErr:" ++ m
| _ => "Other"
} in

-- Test 5: ((fn* [x] x) 42) -> 42
let test5 = Cons(Cons(MSym("fn*"), Cons(Cons(MSym("x"), MNil), Cons(MSym("x"), MNil))), Cons(MNum(42), MNil)) in
let result5 = label exit5 { eval eval initialEnv test5 ~exit5 } in
let r5str = match result5 {
| MNum(n) => "MNum:" ++ intToStr n
| MErr(m) => "MErr:" ++ m
| MClosure(_, _, _) => "MClosure"
| Cons(_, _) => "Cons"
| _ => "Other"
} in

-- Test 6: Test the full count-evens expression from integration test
-- (let* [f (fn* [x] (+ x 1))] (f 5)) -> 6
let test6 =
  Cons(MSym("let*"), Cons(Cons(MSym("f"), Cons(
    Cons(MSym("fn*"), Cons(Cons(MSym("x"), MNil), Cons(
      Cons(MSym("+"), Cons(MSym("x"), Cons(MNum(1), MNil)))
    , MNil)))
  , MNil)), Cons(
    Cons(MSym("f"), Cons(MNum(5), MNil))
  , MNil))) in

let result6 = label exit6 { eval eval initialEnv test6 ~exit6 } in
let r6str = match result6 {
| MNum(n) => "MNum:" ++ intToStr n
| MErr(m) => "MErr:" ++ m
| MClosure(_, _, _) => "MClosure"
| _ => "Other"
} in

-- Test 7: Recursive function using Y combinator style (pass self)
-- (let* [sum (fn* [self n acc] (if (= n 0) acc (self self (- n 1) (+ acc n))))] (sum sum 3 0)) -> 6
let test7 =
  Cons(MSym("let*"), Cons(Cons(MSym("sum"), Cons(
    Cons(MSym("fn*"), Cons(Cons(MSym("self"), Cons(MSym("n"), Cons(MSym("acc"), MNil))), Cons(
      Cons(MSym("if"), Cons(
        Cons(MSym("="), Cons(MSym("n"), Cons(MNum(0), MNil))),
        Cons(MSym("acc"), Cons(
          Cons(MSym("self"), Cons(MSym("self"), Cons(
            Cons(MSym("-"), Cons(MSym("n"), Cons(MNum(1), MNil))),
            Cons(Cons(MSym("+"), Cons(MSym("acc"), Cons(MSym("n"), MNil))), MNil)
          )))
        , MNil))
      ))
    , MNil)))
  , MNil)), Cons(
    Cons(MSym("sum"), Cons(MSym("sum"), Cons(MNum(3), Cons(MNum(0), MNil))))
  , MNil))) in

let result7 = label exit7 { eval eval initialEnv test7 ~exit7 } in
let r7str = match result7 {
| MNum(n) => "MNum:" ++ intToStr n
| MErr(m) => "MErr:" ++ m
| _ => "Other"
} in

-- Output all test results
"1:" ++ r1str ++ " 2:" ++ r2str ++ " 3:" ++ r3str ++ " 4:" ++ r4str ++ " 5:" ++ r5str ++ " 6:" ++ r6str ++ " 7:" ++ r7str
