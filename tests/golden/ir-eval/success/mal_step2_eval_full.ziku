-- ============================================ 
-- MAL Core Definitions
-- Shared by all steps
-- ============================================ 

-- ============================================ 
-- String helpers
-- ============================================ 
let rec strEqFrom = \s1 s2 i =>
  if i >= strLen s1 then true
  else if runeToInt(strAt s1 i) == runeToInt(strAt s2 i) then strEqFrom s1 s2 (i + 1)
  else false
in
let strEq = \s1 s2 =>
  if strLen s1 == strLen s2 then strEqFrom s1 s2 0 else false
in

-- ============================================ 
-- Environment
-- ============================================ 
let emptyEnv = Cons(MNil, MNil) in
let rec lookupBindings = \bindings sym =>
  match bindings {
  | MNil => MNil
  | Cons(Cons(MStr(name), val), rest) =>
    if strEq name sym then Cons(MTrue, val)
    else lookupBindings rest sym
  | _ => MNil
  }
in
let rec envGet = \env sym =>
  match env {
  | Cons(bindings, outer) =>
    match lookupBindings bindings sym {
    | Cons(MTrue, val) => val
    | _ => match outer { | Cons(_, _) => envGet outer sym | _ => MErr("'" ++ sym ++ "' not found") }
    }
  | _ => MErr("invalid env")
  }
in
let envSet = \env sym val =>
  match env {
  | Cons(bindings, outer) => Cons(Cons(Cons(MStr(sym), val), bindings), outer)
  | _ => Cons(Cons(Cons(MStr(sym), val), MNil), MNil)
  }
in
let rec bindParams = \params args env =>
  match params {
  | MNil => env
  | Cons(MSym(name), restParams) =>
    match args {
    | Cons(val, restArgs) => bindParams restParams restArgs (envSet env name val)
    | _ => env
    }
  | _ => env
  }
in

-- ============================================ 
-- Evaluator Helpers
-- ============================================ 
let isTruthy = \val =>
  match val {
  | MNil => false
  | MFalse => false
  | _ => true
  }
in

let applyNative = \op args =>
  if strEq op "+" then
    match args { | Cons(MNum(a), Cons(MNum(b), MNil)) => MNum(a + b) | _ => MErr("+ err") }
  else if strEq op "-" then
    match args { | Cons(MNum(a), Cons(MNum(b), MNil)) => MNum(a - b) | _ => MErr("- err") }
  else if strEq op "/" then
    match args { | Cons(MNum(a), Cons(MNum(b), MNil)) => MNum(a / b) | _ => MErr("/ err") }
  else if strEq op "*" then
    match args { | Cons(MNum(a), Cons(MNum(b), MNil)) => MNum(a * b) | _ => MErr("* err") }
  else if strEq op "mod" then
    match args {
      | Cons(MNum(a), Cons(MNum(b), MNil)) => MNum(a - (a / b) * b)
      | _ => MErr("mod err")
    }
  else if strEq op "=" then
    match args {
    | Cons(MNum(a), Cons(MNum(b), MNil)) => if a == b then MTrue else MFalse
    | _ => MErr("= err")
    }
  else if strEq op "list" then args
  else if strEq op "empty?" then
    match args {
    | Cons(MNil, MNil) => MTrue
    | Cons(Cons(_, _), MNil) => MFalse
    | _ => MTrue
    }
  else if strEq op "first" then
    match args { | Cons(Cons(h, _), MNil) => h | _ => MNil }
  else if strEq op "rest" then
    match args { | Cons(Cons(_, t), MNil) => t | _ => MNil }
  else MErr("unknown native: " ++ op)
in

-- ============================================ 
-- CPS Eval List Helper
-- ============================================ 
let rec evalList = \ev env args =>
  match args {
  | MNil => MNil
  | Cons(h, t) =>
    let hVal = label k { ev ev env h ~k } in
    Cons(hVal, evalList ev env t)
  | _ => MNil
  }
in

-- ============================================ 
-- Reader
-- ============================================ 
let rec skipWhitespace = \s =>
  if strLen s == 0 then s
  else
    let c = strAt s 0 in
    let code = runeToInt c in
    if code == runeToInt ' ' then skipWhitespace (strSub s 1 (strLen s - 1))
    else if code == runeToInt '\t' then skipWhitespace (strSub s 1 (strLen s - 1))
    else if code == runeToInt '\n' then skipWhitespace (strSub s 1 (strLen s - 1))
    else if code == 13 then skipWhitespace (strSub s 1 (strLen s - 1))
    else if code == runeToInt ',' then skipWhitespace (strSub s 1 (strLen s - 1))
    else s
in

let isSpecialCode = \code =>
  if code == runeToInt '(' then true
  else if code == runeToInt ')' then true
  else if code == runeToInt '[' then true
  else if code == runeToInt ']' then true
  else if code == runeToInt '{' then true
  else if code == runeToInt '}' then true
  else false
in

let isWhitespaceCode = \code =>
  if code == runeToInt ' ' then true
  else if code == runeToInt '\t' then true
  else if code == runeToInt '\n' then true
  else if code == 13 then true
  else if code == runeToInt ',' then true
  else false
in

let rec readSymbol = \s i =>
  if i >= strLen s then Cons(MStr(s), MStr(""))
  else
    let c = strAt s i in
    let code = runeToInt c in
    if isWhitespaceCode code then Cons(MStr(strSub s 0 i), MStr(strSub s i (strLen s - i)))
    else if isSpecialCode code then Cons(MStr(strSub s 0 i), MStr(strSub s i (strLen s - i)))
    else readSymbol s (i + 1)
in

let readToken = \s =>
  let s2 = skipWhitespace s in
  if strLen s2 == 0 then Cons(MStr(""), MStr(""))
  else
    let c = strAt s2 0 in
    let code = runeToInt c in
    if isSpecialCode code
    then Cons(MStr(runeToStr c), MStr(strSub s2 1 (strLen s2 - 1)))
    else readSymbol s2 0
in

let rec tokenize = \s =>
  let s2 = skipWhitespace s in
  if strLen s2 == 0 then MNil
  else
    match readToken s2 {
    | Cons(MStr(tok), MStr(rest)) =>
      if strLen tok == 0 then MNil
      else Cons(MStr(tok), tokenize rest)
    | _ => MNil
    }
in

let rec isAllDigits = \s i =>
  if i >= strLen s then true
  else
    let c = strAt s i in
    let code = runeToInt c in
    if code >= runeToInt '0' then
      if code <= runeToInt '9' then isAllDigits s (i + 1)
      else false
    else false
in

let isNumber = \s =>
  if strLen s == 0 then false
  else
    let c = strAt s 0 in
    let code = runeToInt c in
    if code == runeToInt '-' then
      if strLen s > 1 then isAllDigits s 1 else false
    else isAllDigits s 0
in

let parseAtom = \tok =>
  if strEq tok "nil" then MNil
  else if strEq tok "true" then MTrue
  else if strEq tok "false" then MFalse
  else if isNumber tok then MNum(strToInt tok)
  else MSym(tok)
in

let rec readList = \rf tokens =>
  match tokens {
  | Cons(MStr(tok), rest) =>
    if strEq tok ")" then Cons(MNil, rest)
    else
      match rf rf (Cons(MStr(tok), rest)) {
      | Cons(first, rest2) =>
        match readList rf rest2 {
        | Cons(restList, rest3) => Cons(Cons(first, restList), rest3)
        | _ => Cons(MNil, MNil)
        }
      | _ => Cons(MNil, MNil)
      }
  | _ => Cons(MNil, MNil)
  }
in

let rec readForm = \rf tokens =>
  match tokens {
  | Cons(MStr(tok), rest) =>
    if strEq tok "(" then readList rf rest
    else Cons(parseAtom tok, rest)
  | _ => Cons(MNil, MNil)
  }
in

let read_str = \s =>
  let tokens = tokenize s in
  match readForm readForm tokens {
  | Cons(ast, _) => ast
  | _ => MNil
  }
in

-- ============================================ 
-- Printer
-- ============================================ 
let rec prListContents = \pr h t =>
  let hStr = pr h in
  match t {
  | MNil => hStr
  | Cons(h2, t2) => hStr ++ " " ++ prListContents pr h2 t2
  | _ => hStr ++ " . " ++ pr t
  }
in

let rec pr_str = \val =>
  match val {
  | MNum(n) => intToStr n
  | MSym(s) => s
  | MStr(s) => "\"" ++ s ++ "\""
  | MNil => "nil"
  | MTrue => "true"
  | MFalse => "false"
  | Cons(h, t) => "(" ++ prListContents pr_str h t ++ ")"
  | MErr(msg) => "Error: " ++ msg
  | _ => "unknown"
  }
in-- Step 2: Evaluation

let rec eval_ast = \ev env ast =>
  match ast {
  | MSym(s) => envGet env s
  | Cons(h, t) => Cons(ev ev env h, eval_ast ev env t)
  | _ => ast
  }
in

let rec eval = \ev env ast =>
  match ast {
  | Cons(MSym(op), args) =>
    let evaledArgs = eval_ast ev env args in
    applyNative op evaledArgs
  | Cons(h, t) =>
    -- List with non-symbol head (or not a known native)
    let evaledArgs = eval_ast ev env (Cons(h, t)) in
    evaledArgs
  | _ =>
    eval_ast ev env ast
  }
in

pr_str (eval eval emptyEnv (read_str "(+ 1 (* 2 3))"))
