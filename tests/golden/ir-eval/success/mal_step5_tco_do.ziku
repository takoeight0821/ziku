-- MAL Step 5: TCO - Implement `do`
-- Test: (do 1 2 3) -> 3

-- String equality helper
let rec strEqFrom = \s1 s2 i =>
  if i >= strLen s1 then true
  else if runeToInt(strAt s1 i) == runeToInt(strAt s2 i) then strEqFrom s1 s2 (i + 1)
  else false
in
let strEq = \s1 s2 =>
  if strLen s1 == strLen s2 then strEqFrom s1 s2 0 else false
in

-- Environment
let emptyEnv = Cons(MNil, MNil) in
let envSet = \env sym val =>
  match env {
  | Cons(bindings, outer) =>
    Cons(Cons(Cons(MStr(sym), val), bindings), outer)
  | _ => Cons(Cons(Cons(MStr(sym), val), MNil), MNil)
  }
in
let replEnv = envSet emptyEnv "+" (MNative("+")) in

-- Env lookup
let rec lookupBindings = \bindings sym =>
  match bindings {
  | MNil => MNil
  | Cons(Cons(MStr(name), val), rest) =>
    if strEq name sym then Cons(MTrue, val)
    else lookupBindings rest sym
  | _ => MNil
  }
in
let rec envGet = \env sym =>
  match env {
  | Cons(bindings, outer) =>
    match lookupBindings bindings sym {
    | Cons(MTrue, val) => val
    | _ => match outer { | Cons(_, _) => envGet outer sym | _ => MErr("not found") }
    }
  | _ => MErr("invalid env")
  }
in

-- Native application
let applyNative = \op args =>
  if strEq op "+" then
    match args { | Cons(MNum(a), Cons(MNum(b), MNil)) => MNum(a + b) | _ => MErr("+ err") }
  else MErr("unknown native")
in

-- Apply function
let apply = \ev op args env =>
  match op {
  | MNative(name) => applyNative name args
  | _ => MErr("not a function")
  }
in

-- Eval args helper
let rec evalList = \ev args env =>
  match args {
  | MNil => MNil
  | Cons(h, t) =>
    let hVal = label k { ev ev env h ~k } in
    Cons(hVal, evalList ev t env)
  | _ => MNil
  }
in

-- EVAL with explicit CPS (~k continuation)
let rec eval = \ev env ast ~k =>
  match ast {
  | MNum(n) => goto(MNum(n), k)
  | MNil => goto(MNil, k)
  | MTrue => goto(MTrue, k)
  | MFalse => goto(MFalse, k)
  | MSym(s) => goto(envGet env s, k)
  | Cons(head, args) =>
    match head {
    | MSym(s) =>
      if strEq s "do" then
        match args {
        | MNil => goto(MNil, k)
        | Cons(h, MNil) => ev ev env h ~k
        | Cons(h, t) =>
          let ignored = label dk { ev ev env h ~dk } in
          ev ev env (Cons(MSym("do"), t)) ~k
        | _ => goto(MErr("invalid do"), k)
        }
      else
        let opVal = label ok { ev ev env head ~ok } in
        let evaledArgs = evalList ev args env in
        goto(apply ev opVal evaledArgs env, k)
    | _ =>
      let opVal = label ok { ev ev env head ~ok } in
      let evaledArgs = evalList ev args env in
      goto(apply ev opVal evaledArgs env, k)
    }
  | _ => goto(MErr("cannot eval"), k)
  }
in

-- Printer
let prStr = \val =>
  match val {
  | MNum(n) => intToStr n
  | MNil => "nil"
  | MErr(msg) => "Error: " ++ msg
  | _ => "?"
  }
in

-- Test: (do 1 2 3) -> 3
let ast = Cons(MSym("do"), Cons(MNum(1), Cons(MNum(2), Cons(MNum(3), MNil)))) in
let result = label exit { eval eval replEnv ast ~exit } in
prStr result
