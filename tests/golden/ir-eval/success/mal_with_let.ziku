-- Test with let* (without full environment)
-- Input: "(let* [a 1] a)" -> Expected: 1

let rec strEqFrom = \s1 s2 i =>
  if i >= strLen s1 then true
  else
    let c1 = runeToInt (strAt s1 i) in
    let c2 = runeToInt (strAt s2 i) in
    if c1 == c2 then strEqFrom s1 s2 (i + 1)
    else false
in

let strEq = \s1 s2 =>
  if strLen s1 == strLen s2 then strEqFrom s1 s2 0
  else false
in

-- Tokenizer
let rec skipWhitespace = \s =>
  if strLen s == 0 then s
  else
    let c = strAt s 0 in
    let code = runeToInt c in
    if code == runeToInt ' ' then skipWhitespace (strSub s 1 (strLen s - 1))
    else s
in

let isSpecialCode = \code =>
  if code == runeToInt '(' then true
  else if code == runeToInt ')' then true
  else if code == runeToInt '[' then true
  else if code == runeToInt ']' then true
  else false
in

let isWhitespaceCode = \code =>
  if code == runeToInt ' ' then true
  else false
in

let rec readSymbol = \s i =>
  if i >= strLen s then Cons(MStr(s), MStr(""))
  else
    let c = strAt s i in
    let code = runeToInt c in
    if isWhitespaceCode code then Cons(MStr(strSub s 0 i), MStr(strSub s i (strLen s - i)))
    else if isSpecialCode code then Cons(MStr(strSub s 0 i), MStr(strSub s i (strLen s - i)))
    else readSymbol s (i + 1)
in

let readToken = \s =>
  let s2 = skipWhitespace s in
  if strLen s2 == 0 then Cons(MStr(""), MStr(""))
  else
    let c = strAt s2 0 in
    let code = runeToInt c in
    if isSpecialCode code
    then Cons(MStr(runeToStr c), MStr(strSub s2 1 (strLen s2 - 1)))
    else readSymbol s2 0
in

let rec tokenize = \s =>
  let s2 = skipWhitespace s in
  if strLen s2 == 0 then MNil
  else
    match readToken s2 {
    | Cons(MStr(tok), MStr(rest)) =>
      if strLen tok == 0 then MNil
      else Cons(MStr(tok), tokenize rest)
    | _ => MNil
    }
in

-- Parser
let rec isAllDigits = \s i =>
  if i >= strLen s then true
  else
    let c = strAt s i in
    let code = runeToInt c in
    if code >= runeToInt '0' then
      if code <= runeToInt '9' then isAllDigits s (i + 1)
      else false
    else false
in

let isNumber = \s =>
  if strLen s == 0 then false
  else isAllDigits s 0
in

let parseAtom = \tok =>
  if isNumber tok then MNum(strToInt tok)
  else MSym(tok)
in

let rec readVector = \rf tokens =>
  match tokens {
  | Cons(MStr(tok), rest) =>
    if strEq tok "]" then Cons(MNil, rest)
    else
      match rf rf (Cons(MStr(tok), rest)) {
      | Cons(first, rest2) =>
        match readVector rf rest2 {
        | Cons(restList, rest3) => Cons(Cons(first, restList), rest3)
        | _ => Cons(MNil, MNil)
        }
      | _ => Cons(MNil, MNil)
      }
  | _ => Cons(MNil, MNil)
  }
in

let rec readList = \rf tokens =>
  match tokens {
  | Cons(MStr(tok), rest) =>
    if strEq tok ")" then Cons(MNil, rest)
    else
      match rf rf (Cons(MStr(tok), rest)) {
      | Cons(first, rest2) =>
        match readList rf rest2 {
        | Cons(restList, rest3) => Cons(Cons(first, restList), rest3)
        | _ => Cons(MNil, MNil)
        }
      | _ => Cons(MNil, MNil)
      }
  | _ => Cons(MNil, MNil)
  }
in

let rec readForm = \rf tokens =>
  match tokens {
  | Cons(MStr(tok), rest) =>
    if strEq tok "(" then readList rf rest
    else if strEq tok "[" then readVector rf rest
    else Cons(parseAtom tok, rest)
  | _ => Cons(MNil, MNil)
  }
in

let read = \s =>
  let tokens = tokenize s in
  match readForm readForm tokens {
  | Cons(ast, _) => ast
  | _ => MNil
  }
in

-- Simple environment (single scope)
let emptyEnv = MNil in

let rec envGet = \env sym =>
  match env {
  | Cons(binding, rest) =>
    match binding {
    | Cons(MStr(name), val) =>
      if strEq name sym then val
      else envGet rest sym
    | _ => envGet rest sym
    }
  | _ => MErr("not found")
  }
in

let envSet = \env sym val =>
  Cons(Cons(MStr(sym), val), env)
in

-- Eval with let*
let applyOp = \op args =>
  match args {
  | Cons(MNum(a), Cons(MNum(b), MNil)) =>
    if strEq op "+" then MNum(a + b)
    else MErr("unknown op")
  | _ => MErr("arity error")
  }
in

let rec evalList = \ev args env =>
  match args {
  | MNil => MNil
  | Cons(h, t) => Cons(ev ev env h, evalList ev t env)
  | _ => MNil
  }
in

let rec evalBindings = \ev bindings env =>
  match bindings {
  | MNil => env
  | Cons(MSym(name), Cons(value, rest)) =>
    let val = ev ev env value in
    evalBindings ev rest (envSet env name val)
  | _ => env
  }
in

let rec eval = \ev env ast =>
  match ast {
  | MNum(n) => MNum(n)
  | MNil => MNil
  | MSym(s) => envGet env s
  | Cons(head, args) =>
    match head {
    | MSym(letStar) =>
      if strEq letStar "let*" then
        match args {
        | Cons(bindings, Cons(body, MNil)) =>
          let newEnv = evalBindings ev bindings env in
          ev ev newEnv body
        | _ => MErr("let* needs bindings and body")
        }
      else
        let evaledArgs = evalList ev args env in
        applyOp letStar evaledArgs
    | _ => MErr("cannot apply")
    }
  | _ => MErr("cannot eval")
  }
in

-- Test: (let* [a 1] a)
match eval eval emptyEnv (read "(let* [a 1] a)") {
| MNum(n) => n
| _ => 0 - 1
}
