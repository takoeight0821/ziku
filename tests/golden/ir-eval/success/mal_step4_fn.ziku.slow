-- MAL Step 4: Functions and Control Flow (Simplified Environment)
-- Implements: fn*, native functions, application, lexical scoping
-- Returns: Value directly (no Pair)

-- ============================================
-- String helpers
-- ============================================

let rec strEqFrom = \s1 s2 i =>
  if i >= strLen s1 then true
  else
    let c1 = runeToInt (strAt s1 i) in
    let c2 = runeToInt (strAt s2 i) in
    if c1 == c2 then strEqFrom s1 s2 (i + 1)
    else false
in

let strEq = \s1 s2 =>
  if strLen s1 == strLen s2 then strEqFrom s1 s2 0
  else false
in

-- ============================================
-- Tokenizer
-- ============================================

let rec skipWhitespace = \s =>
  if strLen s == 0 then s
  else
    let c = strAt s 0 in
    let code = runeToInt c in
    if code == runeToInt ' ' then skipWhitespace (strSub s 1 (strLen s - 1))
    else if code == runeToInt '\t' then skipWhitespace (strSub s 1 (strLen s - 1))
    else if code == runeToInt '\n' then skipWhitespace (strSub s 1 (strLen s - 1))
    else if code == 13 then skipWhitespace (strSub s 1 (strLen s - 1))
    else if code == runeToInt ',' then skipWhitespace (strSub s 1 (strLen s - 1))
    else s
in

let isSpecialCode = \code =>
  if code == runeToInt '(' then true
  else if code == runeToInt ')' then true
  else if code == runeToInt '[' then true
  else if code == runeToInt ']' then true
  else if code == runeToInt '{' then true
  else if code == runeToInt '}' then true
  else false
in

let isWhitespaceCode = \code =>
  if code == runeToInt ' ' then true
  else if code == runeToInt '\t' then true
  else if code == runeToInt '\n' then true
  else if code == 13 then true
  else if code == runeToInt ',' then true
  else false
in

let rec readSymbol = \s i =>
  if i >= strLen s then Cons(MStr(s), MStr(""))
  else
    let c = strAt s i in
    let code = runeToInt c in
    if isWhitespaceCode code then Cons(MStr(strSub s 0 i), MStr(strSub s i (strLen s - i)))
    else if isSpecialCode code then Cons(MStr(strSub s 0 i), MStr(strSub s i (strLen s - i)))
    else readSymbol s (i + 1)
in

let readToken = \s =>
  let s2 = skipWhitespace s in
  if strLen s2 == 0 then Cons(MStr(""), MStr(""))
  else
    let c = strAt s2 0 in
    let code = runeToInt c in
    if isSpecialCode code
    then Cons(MStr(runeToStr c), MStr(strSub s2 1 (strLen s2 - 1)))
    else readSymbol s2 0
in

let rec tokenize = \s =>
  let s2 = skipWhitespace s in
  if strLen s2 == 0 then MNil
  else
    match readToken s2 {
    | Cons(MStr(tok), MStr(rest)) =>
      if strLen tok == 0 then MNil
      else Cons(MStr(tok), tokenize rest)
    | _ => MNil
    }
in

-- ============================================
-- Parser
-- ============================================

let rec isAllDigits = \s i =>
  if i >= strLen s then true
  else
    let c = strAt s i in
    let code = runeToInt c in
    if code >= runeToInt '0' then
      if code <= runeToInt '9' then isAllDigits s (i + 1)
      else false
    else false
in

let isNumber = \s =>
  if strLen s == 0 then false
  else
    let c = strAt s 0 in
    let code = runeToInt c in
    if code == runeToInt '-' then
      if strLen s > 1 then isAllDigits s 1 else false
    else isAllDigits s 0
in

let parseAtom = \tok =>
  if strEq tok "nil" then MNil
  else if strEq tok "true" then MTrue
  else if strEq tok "false" then MFalse
  else if isNumber tok then MNum(strToInt tok)
  else MSym(tok)
in

let rec readVector = \rf tokens =>
  match tokens {
  | Cons(MStr(tok), rest) =>
    if strEq tok "]" then Cons(MNil, rest)
    else
      match rf rf (Cons(MStr(tok), rest)) {
      | Cons(first, rest2) =>
        match readVector rf rest2 {
        | Cons(restList, rest3) => Cons(Cons(first, restList), rest3)
        | _ => Cons(MNil, MNil)
        }
      | _ => Cons(MNil, MNil)
      }
  | _ => Cons(MNil, MNil)
  }
in

let rec readList = \rf tokens =>
  match tokens {
  | Cons(MStr(tok), rest) =>
    if strEq tok ")" then Cons(MNil, rest)
    else
      match rf rf (Cons(MStr(tok), rest)) {
      | Cons(first, rest2) =>
        match readList rf rest2 {
        | Cons(restList, rest3) => Cons(Cons(first, restList), rest3)
        | _ => Cons(MNil, MNil)
        }
      | _ => Cons(MNil, MNil)
      }
  | _ => Cons(MNil, MNil)
  }
in

let rec readForm = \rf tokens =>
  match tokens {
  | Cons(MStr(tok), rest) =>
    if strEq tok "(" then readList rf rest
    else if strEq tok "[" then readVector rf rest
    else Cons(parseAtom tok, rest)
  | _ => Cons(MNil, MNil)
  }
in

let read = \s =>
  let tokens = tokenize s in
  match readForm readForm tokens {
  | Cons(ast, _) => ast
  | _ => MNil
  }
in

-- ============================================
-- Printer
-- ============================================

let rec prListContents = \pr h t =>
  let hStr = pr h in
  match t {
  | MNil => hStr
  | Cons(h2, t2) => hStr ++ " " ++ prListContents pr h2 t2
  | _ => hStr ++ " . " ++ pr t
  }
in

let rec prStr = \val =>
  match val {
  | MNum(n) => intToStr n
  | MSym(s) => s
  | MStr(s) => s
  | MNil => "nil"
  | MTrue => "true"
  | MFalse => "false"
  | MErr(msg) => "Error: " ++ msg
  | Cons(h, t) => "(" ++ prListContents prStr h t ++ ")"
  | MNative(name) => "#<function>"
  | MClosure(p, b, e) => "#<function>"
  }
in

-- ============================================
-- Environment
-- ============================================

let emptyEnv = Cons(MNil, MNil)
in

let rec lookupBindings = \bindings sym =>
  match bindings {
  | MNil => MNil
  | Cons(binding, rest) =>
    match binding {
    | Cons(MStr(name), val) =>
      if strEq name sym then Cons(MTrue, val)
      else lookupBindings rest sym
    | _ => lookupBindings rest sym
    }
  | _ => MNil
  }
in

let rec envGet = \env sym =>
  match env {
  | Cons(bindings, outer) =>
    match lookupBindings bindings sym {
    | Cons(MTrue, val) => val
    | _ =>
      match outer {
      | Cons(_, _) => envGet outer sym
      | _ => MErr(sym ++ " not found")
      }
    }
  | _ => MErr("invalid env")
  }
in

let envSet = \env sym val =>
  match env {
  | Cons(bindings, outer) =>
    Cons(Cons(Cons(MStr(sym), val), bindings), outer)
  | _ => Cons(Cons(Cons(MStr(sym), val), MNil), MNil)
  }
in

let rec bindParams = \params args env =>
  match params {
  | MNil => env
  | Cons(MSym(name), restParams) =>
    match args {
    | Cons(val, restArgs) =>
      bindParams restParams restArgs (envSet env name val)
    | _ => env
    }
  | _ => env
  }
in

-- ============================================
-- Evaluator
-- ============================================

let rec evalList = \ev args env =>
  match args {
  | MNil => MNil
  | Cons(h, t) => Cons(ev ev env h, evalList ev t env)
  | _ => MNil
  }
in

let applyNative = \op args =>
  if strEq op "+" then
    match args {
    | Cons(MNum(a), Cons(MNum(b), MNil)) => MNum(a + b)
    | _ => MErr("+ error")
    }
  else if strEq op "-" then
    match args {
    | Cons(MNum(a), Cons(MNum(b), MNil)) => MNum(a - b)
    | _ => MErr("- error")
    }
  else if strEq op "*" then
    match args {
    | Cons(MNum(a), Cons(MNum(b), MNil)) => MNum(a * b)
    | _ => MErr("* error")
    }
  else if strEq op "/" then
    match args {
    | Cons(MNum(a), Cons(MNum(b), MNil)) => MNum(a / b)
    | _ => MErr("/ error")
    }
  else if strEq op "list" then args
  else if strEq op "count" then
    match args {
    | Cons(l, MNil) =>
      let rec count = \lst => match lst { | Cons(_, t) => 1 + count t | _ => 0 } in
      MNum(count l)
    | _ => MErr("count error")
    }
  else if strEq op "empty?" then
    match args {
    | Cons(MNil, MNil) => MTrue
    | _ => MFalse
    }
  else MErr("unknown native: " ++ op)
in

let apply = \ev op args =>
  match op {
  | MNative(name) => applyNative name args
  | MClosure(params, body, cEnv) =>
    let newEnv = bindParams params args cEnv in
    ev ev newEnv body
  | _ => MErr("cannot apply non-function")
  }
in

let rec evalBindings = \ev bindings env =>
  match bindings {
  | MNil => env
  | Cons(MSym(name), Cons(value, rest)) =>
    let val = ev ev env value in
    evalBindings ev rest (envSet env name val)
  | _ => env
  }
in

let rec eval = \ev env ast =>
  match ast {
  | MNum(n) => MNum(n)
  | MStr(s) => MStr(s)
  | MNil => MNil
  | MTrue => MTrue
  | MFalse => MFalse
  | MErr(msg) => MErr(msg)
  | MNative(n) => MNative(n)
  | MClosure(p, b, e) => MClosure(p, b, e)

  | MSym(s) => envGet env s

  | Cons(head, args) =>
    match head {
    | MSym("let*") =>
      match args {
      | Cons(bindings, Cons(body, MNil)) =>
        let localEnv = evalBindings ev bindings env in
        ev ev localEnv body
      | _ => MErr("let* error")
      }
    | MSym("if") =>
      match args {
      | Cons(test_, Cons(then_, Cons(else_, MNil))) =>
        let testVal = ev ev env test_ in
        match testVal {
        | MNil => ev ev env else_
        | MFalse => ev ev env else_
        | _ => ev ev env then_
        }
      | _ => MErr("if error")
      }
    | MSym("do") =>
      let rec last = \l =>
        match l {
        | Cons(h, MNil) => h
        | Cons(h, t) => last t
        | _ => MNil
        }
      in
      last (evalList ev args env)
    | MSym("fn*") =>
      match args {
      | Cons(params, Cons(body, MNil)) =>
        MClosure(params, body, env)
      | _ => MErr("fn* error")
      }
    | _ =>
      let opVal = ev ev env head in
      let evaledArgs = evalList ev args env in
      apply ev opVal evaledArgs
    }

  | _ => MErr("cannot eval")
  }
in

let replEnv =
  let e0 = emptyEnv in
  let e1 = envSet e0 "+" (MNative("+")) in
  let e2 = envSet e1 "-" (MNative("-")) in
  let e3 = envSet e2 "*" (MNative("*")) in
  let e4 = envSet e3 "/" (MNative("/")) in
  let e5 = envSet e4 "list" (MNative("list")) in
  let e6 = envSet e5 "count" (MNative("count")) in
  envSet e6 "empty?" (MNative("empty?"))
in

-- ============================================
-- Test
-- ============================================

match eval eval replEnv (read "(if true 1 2)") {
| v1 =>
match eval eval replEnv (read "(if false 1 2)") {
| v2 =>
match eval eval replEnv (read "(let* [a 1] (+ a 1))") {
| v3 =>
match eval eval replEnv (read "((fn* [a b] (+ a b)) 3 4)") {
| v4 =>
match eval eval replEnv (read "(let* [add (fn* [a b] (+ a b))] (add 1 2))") {
| v5 =>
  Cons(prStr v1, Cons(prStr v2, Cons(prStr v3, Cons(prStr v4, Cons(prStr v5, MNil)))))
}}}}}