-- Step 4: Functions and Control Flow

-- ============================================ 
-- Eval Helper
-- ============================================ 

let rec eval_ast = \ev env ast =>
  match ast {
  | MSym(s) => Pair(envGet env s, env)
  | Cons(h, t) =>
    match ev ev env h {
    | Pair(hEvaled, env2) =>
      match eval_ast ev env2 t {
      | Pair(tEvaled, env3) => Pair(Cons(hEvaled, tEvaled), env3)
      }
    }
  | _ => Pair(ast, env)
  }
in

let rec evalList = \ev args env =>
  match args {
  | MNil => Pair(MNil, env)
  | Cons(h, t) =>
    match ev ev env h {
    | Pair(hEvaled, env2) =>
      match evalList ev t env2 {
      | Pair(tEvaled, env3) => Pair(Cons(hEvaled, tEvaled), env3)
      }
    }
  | _ => Pair(MNil, env)
  }
in

let rec evalBindings = \ev bindings env =>
  match bindings {
  | MNil => env
  | Cons(MSym(name), Cons(value, rest)) =>
    match ev ev env value {
    | Pair(val, _) => evalBindings ev rest (envSet env name val)
    }
  | _ => env
  }
in

-- ============================================ 
-- Debug Helper
-- ============================================ 
let rec my_pr_str = \val =>
  match val {
  | MClosure(p, b, e) => "Closure"
  | MNative(n) => "Native: " ++ n
  | MErr(msg) => "ErrorVal: " ++ msg
  | Pair(v, _) => my_pr_str v
  | Cons(h, t) => "(" ++ my_pr_str h ++ " " ++ my_pr_str t ++ ")"
  | _ => pr_str val
  }
in

-- ============================================ 
-- Apply
-- ============================================ 

let apply = \ev func args =>
  match func {
  | MNative(name) => applyNative name args
  | MClosure(params, body, closedEnv) =>
    let newEnvFrame = Cons(MNil, closedEnv) in
    let appliedEnv = bindParams params args newEnvFrame in
    match ev ev appliedEnv body {
    | Pair(val, _) => val
    }
  | _ => MErr("not a function: " ++ my_pr_str func)
  }
in

-- ============================================ 
-- Eval
-- ============================================ 

let rec eval = \ev env ast =>
  match ast {
  -- Atoms
  | MNum(n) => Pair(MNum(n), env)
  | MStr(s) => Pair(MStr(s), env)
  | MNil => Pair(MNil, env)
  | MTrue => Pair(MTrue, env)
  | MFalse => Pair(MFalse, env)
  | MErr(msg) => Pair(MErr(msg), env)
  | MNative(n) => Pair(MNative(n), env)
  | MClosure(p,b,e) => Pair(MClosure(p,b,e), env)

  -- Symbol lookup
  | MSym(s) => Pair(envGet env s, env)

  -- Lists (Forms)
  | Cons(head, args) =>
    match head {
    -- Special Forms
    | MSym("def!") =>
      match args {
      | Cons(MSym(name), Cons(value, MNil)) =>
        match ev ev env value {
        | Pair(val, _) => Pair(val, envSet env name val)
        }
      | _ => Pair(MErr("def! requires symbol and value"), env)
      }
    | MSym("let*") =>
      match args {
      | Cons(bindings, Cons(body, MNil)) =>
        let newEnvFrame = Cons(MNil, env) in
        let localEnv = evalBindings ev bindings newEnvFrame in
        match ev ev localEnv body {
        | Pair(val, _) => Pair(val, env)
        }
      | _ => Pair(MErr("let* requires bindings and body"), env)
      }
    | MSym("do") =>
      match evalList ev args env {
      | Pair(evaledList, env2) =>
        let rec last = \l =>
          match l {
          | Cons(h, MNil) => h
          | Cons(h, t) => last t
          | _ => MNil
          }
        in
        Pair(last evaledList, env2)
      }
    | MSym("if") =>
      match args {
      | Cons(test_, Cons(then_, Cons(else_, MNil))) =>
        match ev ev env test_ {
        | Pair(testVal, env2) =>
          match testVal {
          | MNil => ev ev env2 else_
          | MFalse => ev ev env2 else_
          | _ => ev ev env2 then_
          }
        }
      -- Handle if without else (defaults to nil)
      | Cons(test_, Cons(then_, MNil)) =>
        match ev ev env test_ {
        | Pair(testVal, env2) =>
          match testVal {
          | MNil => Pair(MNil, env2)
          | MFalse => Pair(MNil, env2)
          | _ => ev ev env2 then_
          }
        }
      | _ => Pair(MErr("if requires test, then, and optional else"), env)
      }
    | MSym("fn*") =>
      match args {
      | Cons(params, Cons(body, MNil)) =>
        Pair(MClosure(params, body, env), env)
      | _ => Pair(MErr("fn* requires params and body: " ++ my_pr_str args), env)
      }

    -- Function Application
    | _ =>
      match ev ev env head {
      | Pair(func, env2) =>
        match evalList ev args env2 {
        | Pair(evaledArgs, env3) =>
          Pair(apply ev func evaledArgs, env3)
        }
      }
    }

  | _ => Pair(MErr("cannot eval"), env)
  }
in

-- ============================================ 
-- REPL
-- ============================================ 

let replEnv = 
  let e0 = emptyEnv in
  let e1 = envSet e0 "+" (MNative("+")) in
  let e2 = envSet e1 "-" (MNative("-")) in
  let e3 = envSet e2 "*" (MNative("*")) in
  let e4 = envSet e3 "/" (MNative("/")) in
  let e5 = envSet e4 "list" (MNative("list")) in
  let e6 = envSet e5 "empty?" (MNative("empty?")) in
  let e7 = envSet e6 "first" (MNative("first")) in
  let e8 = envSet e7 "rest" (MNative("rest")) in
  let e9 = envSet e8 "=" (MNative("=")) in
  e9
in

let rec repl_loop = \env =>
  let line = readLine(()) in
  if strLen line == 0 then ()
  else
    let ast = read_str line in
    match eval eval env ast {
    | Pair(val, newEnv) =>
      let out = pr_str val in
      let ignored = println(out) in
      repl_loop newEnv
    }
in

repl_loop replEnv
